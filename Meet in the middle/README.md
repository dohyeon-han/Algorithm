# Meet in the middle(중간에서 만나기)

Meet in the middle 알고리즘은 전체 크기를 반으로 나눠 계산의 양을 줄이는 방식의 알고리즘입니다.<br><br>
![](2021-11-02-14-19-32.png)
&nbsp;예를 들어 크기가 n인 배열이 있고,
이 배열 전체를 탐색하는데 $2^n$이 드는 문제가 있다고 가정합니다.<br>
&nbsp;만약 이 알고리즘을 사용한다면, 탐색의 범위가 각각 반으로 줄어들어 $2^{n/2} \times 2$의 시간이 소요되어 계산 양이 줄어들게 됩니다. 물론 나눠진 부분을 합하여 결과를 도출하는데 추가적인 계산이 들 수도 있지만, 보통 탐색 연산보다는 적은 시간이 소요됩니다.
<br><br><br>

## 1208번: 부분 수열의 합 2
https://www.acmicpc.net/problem/1208
![](2021-11-02-14-41-08.png)

&nbsp;부분 수열의 합이 S가 되는 수열의 수를 구하는 문제입니다. <br>
&nbsp;모든 부분 수열의 합을 계산한다고 생각해 볼 수 있습니다. 하지만 모든 부분수열의 개수는 $2^{N}$이고 최대 $2^{40}$이 되어 하나씩 구할 경우 시간 초과가 납니다. 만약 탐색 범위를 반으로 줄인다면 $2^{20}$이 되어 계산의 양을 줄일 수 있습니다. 해당 방법을 이용하여 문제를 풀 수 있습니다.<br>

* DFS로 0 ~ N/2 - 1 인덱스까지의 각 부분 수열의 합(sum)을 계산하고 그 합을 인덱스로 하여 lsum[sum]의 개수를 증가시킨다. 이때 합이 음수가 될 수 있으므로 2000000을 더하여 양수로 만들어 준다. (left())
* DFS로 N/2 ~ N-1 인덱스까지의 각 부분수열의 합(sum)을 구하고 lsum[S - sum + 2000000]을 결과값에 더한다. (right())
* S가 0일 경우 부분 수열의 크기는 0인 경우가 포함되어 있으므로 결과값에서 1을 빼준다.

### 코드
https://github.com/dohyeon-han/BOJ/blob/main/Meet%20in%20the%20middle/1208.cpp
<br><br><br>

## 1450번: 냅색문제
https://www.acmicpc.net/problem/1450
![](2021-11-02-14-42-35.png)

&nbsp;위의 문제와 유사한 문제입니다. 모든 부분 수열의 합은 최대 $2^{30}$으로 약 10억번의 계산이 필요합니다.<br> &nbsp;만약 n을 반으로 줄인다면 $2^{15}$가 되어 충분히 빠르게 계산할만한 값이 됩니다. 다음과 같은 방법으로 탐색 범위를 반으로 줄일 수 있습니다.<br>

* 배열을 반으로 나눠 왼쪽 배열에서 모든 부분수열의 합을 계산한다. (leftWei[])
* 합을 오름차순으로 정렬한다.
* 나머지 오른쪽 배열에서 모든 부분수열의 합을 계산한다. (rightWei[])
* (최대무게 - rightWei[i])를 upper bound를 통해 leftWei에서 찾으면 그 인덱스의 값이 넣을 수 있는 무게의 수가 되고 인덱스 값의 총 합이 가방에 넣을 수 있는 방법의 수가 된다.


### 코드
https://github.com/dohyeon-han/BOJ/blob/main/Meet%20in%20the%20middle/1450.cpp
<br><br><br>

## 22882번: 시험 문제 출제
https://www.acmicpc.net/problem/22882
![](2021-11-02-14-45-32.png)

&nbsp; $(1,1)$에서 $(N,N)$까지의 경로를 수열로하여 최대 부분합이 K인 수열의 개수를 구하는 문제입니다.
$(1,1)$에서 $(20,20)$까지의 경로 수는 오른쪽으로 이동하는 횟수 19번, 아래로 이동하는 횟수 19번 총 $38 \choose 19$로 매우 큰 수가 됩니다.<br>
&nbsp;2차원 배열의 칸을 $(x,y)$라 할때, $(1,1), (N,N)$에서 $x + y = N$을 만족하는 대각선까지의 경로는 트리 형태이므로 그 개수는 약 $2*2^{19}$이 되어 계산할 수 있는 수가 됩니다.

 ![](2021-11-02-18-35-44.png)

경로를 지나면서 최대 부분합을 구해야 하는데, 이전 부분 합을 pre, 최대 부분 합을 mx라 할 때,<br>
$pre = max(pre+arr[y][x], pre)$<br>
$mx = max(mx,pre)$<br>
계산을 통해 각 수열을 지나면서 최대 부분합을 구할 수 있습니다.<br>

두 수열를 합친 최대 부분합은 $max(mx_1,mx_2,pre_1+pre_2)$ 계산을 통해 구할 수 있습니다.
두 수열이 만나는 지점에서 $mx_1<=k$인 $pre_1$과 $mx_2<=k$인 $pre_2$를 이용해
최대 부분합이 k이하인 수열의 개수를 구할 수 있는데 이를 $f(k)$라 한다면
$f(k)-f(k-1)$로 최대 부분합이 k인 수열을 구할 수 있습니다.<br>
$f(n)$에서 $pre_1, pre_2$의 값을 각각 배열로 만들어 정렬한다면 투 포인터를 이용해 $O(n)$으로 구할 수 있습니다.

### 코드
https://github.com/dohyeon-han/BOJ/blob/main/Meet%20in%20the%20middle/22882.cpp







